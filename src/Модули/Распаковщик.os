// ----------------------------------------------------------
// This Source Code Form is subject to the terms of the
// Mozilla Public License, v.2.0. If a copy of the MPL
// was not distributed with this file, You can obtain one
// at http://mozilla.org/MPL/2.0/.
// ----------------------------------------------------------
// Codebase: https://github.com/ArKuznetsov/yard/
// ----------------------------------------------------------
//
// Реализация распаковки EFD-файла на основе обработки:
// https://infostart.ru/public/618906/
//
// ----------------------------------------------------------

Перем Лог;     // Объект       - объект записи лога приложения

#Область ПрограммныйИнтерфейс

// Процедура - извлекает указанные файлы из архива в формате EFD (1С)
//
// Параметры:
//  ПутьКАрхивуEFD                    - Строка          - путь к архиву в формате EFD
//  КаталогРаспаковки                 - Строка          - путь к каталогу для сохранения результата распаковки
//  КаталогВАрхивеДляРаспаковкиEFD    - Строка          - регулярное выражение, отбора каталогов
//                                                        в архиве EFD для распаковки
//  ВыбранныеФайлы                    - Строка          - имя файла или список файлов для распаковки
//                                      Массив(Строка)    если не указан, то распаковываются все файлы
//  РаспаковкаКаталогов - Строка                        - вариант распаковки каталогов
//
Процедура РаспаковатьШаблонКонфигурации1С(Знач ПутьКАрхивуEFD,
                                          Знач КаталогРаспаковки,
                                          Знач КаталогВАрхивеДляРаспаковкиEFD,
                                          Знач ВыбранныеФайлы = "",
                                          Знач РаспаковкаКаталогов = "") Экспорт

	ВремФайлАрхива = Новый Файл(ПутьКАрхивуEFD);

	ПутьКФайлуDeflate = ИзвлечьАрхивDeflate(ПутьКАрхивуEFD);
	
	ЗаписатьВыбранныеФайлы(ПутьКФайлуDeflate,
	                       КаталогРаспаковки,
	                       КаталогВАрхивеДляРаспаковкиEFD,
	                       ВыбранныеФайлы,
	                       РаспаковкаКаталогов);

	УдалитьФайлы(ПутьКФайлуDeflate);

КонецПроцедуры // РаспаковатьШаблонКонфигурации1С()

// Процедура - выполняет распаковку архива с использованием установленного в системе архиватора 7-zip
//   
// Параметры:
//  ПутьКАрхиву         - Строка     - путь к архиву
//  КаталогРаспаковки   - Строка     - путь к каталогу для сохранения результата распаковки
//
Процедура РаспаковатьАрхив(Знач ПутьКАрхиву, Знач КаталогРаспаковки) Экспорт
	
	ПутьК7ЗИП = НайтиАрхиватор();
	
	Если НЕ ЗначениеЗаполнено(ПутьК7ЗИП) Тогда
		ВызватьИсключение "7-Zip не найден";
	КонецЕсли;

	ДанныеИсхФайла = Новый Файл(ПутьКАрхиву);
	// TODO: Пока получаем файл повторно по полному пути, чтобы в объекте "Файл" был полный путь
	ДанныеИсхФайла = Новый Файл(ДанныеИсхФайла.ПолноеИмя);

	ИмяФайлаОшибокАрхивации = ДанныеИсхФайла.Путь + "7z_error_messages.txt";

	КомандаАрхиватора = СтрШаблон("x -aoa -y -o""%1"" ""%2""",
	                              КаталогРаспаковки,
	                              ДанныеИсхФайла.ПолноеИмя);
	
	КомандаЗапроса = Новый Команда();

	КомандаЗапроса.УстановитьКоманду(ПутьК7ЗИП);
	
	КомандаЗапроса.ДобавитьПараметр(КомандаАрхиватора);

	КомандаЗапроса.УстановитьИсполнениеЧерезКомандыСистемы(Ложь);
	КомандаЗапроса.ПоказыватьВыводНемедленно(Истина);

	КодВозврата = КомандаЗапроса.Исполнить();

	Если НЕ КодВозврата = 0 Тогда

		ФайлОшибокАрх = Новый Файл(ИмяФайлаОшибокАрхивации);
		Если ФайлОшибокАрх.Существует() Тогда
			ЧтениеФайла = Новый ЧтениеТекста(ИмяФайлаОшибокАрхивации);
			СтрокаФайлаОшибок = ЧтениеФайла.ПрочитатьСтроку();
			Пока СтрокаФайлаОшибок <> Неопределено Цикл
				СтрокаФайлаОшибок = ЧтениеФайла.ПрочитатьСтроку();
			КонецЦикла;
			ЧтениеФайла.Закрыть();
			УдалитьФайлы(ИмяФайлаОшибокАрхивации);
		КонецЕсли;

		Возврат;
	КонецЕсли;

КонецПроцедуры // РаспаковатьАрхив()

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункцииРаботыАрхивами

// Функция - извлекает из архива в формате EFD (1С) архив в формате Deflate
// и возвращает путь к извлеченному файлу
//
// Параметры:
//  ПутьКАрхивуEFD      - Строка     - путь к архиву в формате EFD
//  КаталогРаспаковки   - Строка     - путь к каталогу для сохранения результата распаковки,
//                                     если не указан то совпадает с расположением архива EFD
//
// Возвращаемое значение:
//  Строка  - путь к извлеченному файлу
//
Функция ИзвлечьАрхивDeflate(Знач ПутьКАрхивуEFD, Знач КаталогРаспаковки = "")

	ВремФайлАрхива = Новый Файл(ПутьКАрхивуEFD);

	Если НЕ ЗначениеЗаполнено(КаталогРаспаковки) Тогда
		КаталогРаспаковки = ВремФайлАрхива.Путь;
	КонецЕсли;

	ИмяФайлаDeflate = СтрШаблон("%1_%2.ifl", ВремФайлАрхива.ИмяБезРасширения, Новый УникальныйИдентификатор());

	ПутьКФайлуZIP = ПреобразоватьАрхивEFDвZIP(ПутьКАрхивуEFD, ИмяФайлаDeflate, КаталогРаспаковки);

	ИзвлечьФайлИзАрхиваZIP(ПутьКФайлуZIP, КаталогРаспаковки);

	УдалитьФайлы(ПутьКФайлуZIP);

	Возврат ОбъединитьПути(КаталогРаспаковки, ИмяФайлаDeflate);

КонецФункции // ИзвлечьАрхивDeflate()

// Функция - преобразует архив в формате EFD (1С) в формат ZIP
// путем добавления необходимых заголовков
//
// Параметры:
//  ПутьКАрхивуEFD      - Строка     - путь к архиву в формате EFD
//  ИмяФайлаDeflate     - Строка     - тут будет возвращено имя файла архива в формате EFD
//  КаталогРаспаковки   - Строка     - путь к каталогу для сохранения результата преобразования,
//                                     если не указан то совпадает с расположением архива EFD
//
// Возвращаемое значение:
//  Строка  - путь к созданному файлу ZIP
//
Функция ПреобразоватьАрхивEFDвZIP(Знач ПутьКАрхивуEFD, Знач ИмяФайлаDeflate, Знач КаталогРаспаковки = "")

	// Структура ZIP файла:
	// https://blog2k.ru/archives/3391
	// https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html
	// https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
	
	ВремФайлАрхива = Новый Файл(ПутьКАрхивуEFD);

	Если НЕ ЗначениеЗаполнено(КаталогРаспаковки) Тогда
		КаталогРаспаковки = ВремФайлАрхива.Путь;
	КонецЕсли;

	ИмяФайлаZIP     = СтрШаблон("%1_%2.zip", ВремФайлАрхива.ИмяБезРасширения, Новый УникальныйИдентификатор());

	ПутьКАрхивуZIP = ОбъединитьПути(КаталогРаспаковки, ИмяФайлаZIP);

	ПотокЧтенияEFD = Новый ФайловыйПоток(ПутьКАрхивуEFD, РежимОткрытияФайла.Открыть);
	
	ДлинаИмениСжатогоФайла    = СтрДлина(ИмяФайлаDeflate);
	РазмерСжатогоФайла        = ПотокЧтенияEFD.Размер();
	CRC                       = 0;
	РазмерРаспакованногоФайла = Pow(2, 32) - 1; // максимально возможный размер
	ДатаВремя                 = ТекущаяДата();
	ВремяФайла                = ВремяFAT(ДатаВремя);
	ДатаФайла                 = ДатаFAT(ДатаВремя);
	
	См0  = 0;
	См4  = 4;
	См6  = 6;
	См8  = 8;
	См10 = 10;
	См12 = 12;
	См14 = 14;
	См16 = 16;
	См18 = 18;
	См20 = 20;
	См22 = 22;
	См24 = 24;
	См26 = 26;
	См28 = 28;
	См30 = 30;
	См32 = 32;
	См34 = 34;
	См36 = 36;
	См38 = 38;
	См42 = 42;

	// [Local File Header]
	ДлинаФиксированнойЧастиLFH = 30;
	
	Сигнатура1           = 67324752;     // Обязательная сигнатура 0x04034B50
	ВерсияДляРаспаковки  = 20;           // Минимальная версия для распаковки
	БитовыйФлаг          = 2050;         // Битовый флаг
	МетодСжатия          = 8;            // Метод сжатия (0 - без сжатия, 8 - deflate)
	
	БуферЗаголовка = Новый БуферДвоичныхДанных(ПолучитьРазмерЗаголовкаZIPФайла(ДлинаИмениСжатогоФайла));

	БуферЗаголовка.ЗаписатьЦелое32(См0 , Сигнатура1);                // Обязательная сигнатура 0x04034B50
	БуферЗаголовка.ЗаписатьЦелое16(См4 , ВерсияДляРаспаковки);       // Минимальная версия для распаковки
	БуферЗаголовка.ЗаписатьЦелое16(См6 , БитовыйФлаг);               // Битовый флаг
	БуферЗаголовка.ЗаписатьЦелое16(См8 , МетодСжатия);               // Метод сжатия (0 - без сжатия, 8 - deflate)
	БуферЗаголовка.ЗаписатьЦелое16(См10, ВремяФайла);                // Время модификации файла
	БуферЗаголовка.ЗаписатьЦелое16(См12, ДатаФайла);                 // Дата модификации файла
	БуферЗаголовка.ЗаписатьЦелое32(См14, CRC);                       // Контрольная сумма
	БуферЗаголовка.ЗаписатьЦелое32(См18, РазмерСжатогоФайла);        // Сжатый размер
	БуферЗаголовка.ЗаписатьЦелое32(См22, РазмерРаспакованногоФайла); // Несжатый размер
	БуферЗаголовка.ЗаписатьЦелое16(См26, ДлинаИмениСжатогоФайла);    // Длина название файла
	БуферЗаголовка.ЗаписатьЦелое16(См28, 0);                         // Длина поля с дополнительными данными
	
	// Название файла
	Для й = 0 По ДлинаИмениСжатогоФайла - 1 Цикл
		БуферЗаголовка.Установить(ДлинаФиксированнойЧастиLFH + й, КодСимвола(Сред(ИмяФайлаDeflate, й + 1, 1)));
	КонецЦикла;
	
	// [Сжатые данные]
	ПотокЗаписи = Новый ФайловыйПоток(ПутьКАрхивуZIP, РежимОткрытияФайла.СоздатьНовый);
	ПотокЗаписи.Записать(БуферЗаголовка, 0, БуферЗаголовка.Размер);

	ОсталосьЗаписать = РазмерСжатогоФайла;
	РазмерБуфера = 10485760; // 10 Mb
	Пока ОсталосьЗаписать > 0 Цикл
		БуферЗаписи = Новый БуферДвоичныхДанных(Мин(РазмерБуфера, ОсталосьЗаписать));
		ПотокЧтенияEFD.Прочитать(БуферЗаписи, 0, БуферЗаписи.Размер);
		ПотокЗаписи.Записать(БуферЗаписи, 0, БуферЗаписи.Размер);
		ОсталосьЗаписать = ОсталосьЗаписать - Мин(РазмерБуфера, ОсталосьЗаписать);
	КонецЦикла;
	ПотокЧтенияEFD.Закрыть();

	// [Central directory file header]
	ДлинаФиксированнойЧастиCDFH	= 46;
	ДлинаДополнительныхДанных	= 0; // Длина поля с дополнительными данными
	
	Сигнатура2           = 33639248;     // Обязательная сигнатура 0x02014B50
	ВерсияДляСоздания    = 814;          // Версия для создания
	ВнешниеАтрибутыФайла = 2176057344;   // Внешние аттрибуты файла

	ТекущееСмещение = 0;

	БуферОкончания = Новый БуферДвоичныхДанных(ПолучитьРазмерОкончанияZIPФайла(ДлинаИмениСжатогоФайла));

	БуферОкончания.ЗаписатьЦелое32(ТекущееСмещение + См0 , Сигнатура2);                // Обязательная сигнатура 0x02014B50
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См4 , ВерсияДляСоздания);         // Версия для создания
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См6 , ВерсияДляРаспаковки);       // Минимальная версия для распаковки
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См8 , БитовыйФлаг);               // Битовый флаг
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См10, МетодСжатия);
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См12, ВремяФайла);                // Время модификации файла
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См14, ДатаФайла);                 // Дата модификации файла
	БуферОкончания.ЗаписатьЦелое32(ТекущееСмещение + См16, CRC);                       // Контрольная сумма
	БуферОкончания.ЗаписатьЦелое32(ТекущееСмещение + См20, РазмерСжатогоФайла);        // Сжатый размер
	БуферОкончания.ЗаписатьЦелое32(ТекущееСмещение + См24, РазмерРаспакованногоФайла); // Несжатый размер
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См28, ДлинаИмениСжатогоФайла);    // Длина название файла
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См30, ДлинаДополнительныхДанных);
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См32, 0);                         // Длина комментариев к файлу
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См34, 0);                         // Номер диска
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См36, 0);                         // Внутренние аттрибуты файла
	БуферОкончания.ЗаписатьЦелое32(ТекущееСмещение + См38, ВнешниеАтрибутыФайла);      // Внешние аттрибуты файла
	БуферОкончания.ЗаписатьЦелое32(ТекущееСмещение + См42, 0);                     // Смещение до структуры LocalFileHeader
	
	// Название файла
	Для й = 0 По ДлинаИмениСжатогоФайла - 1 Цикл
		СимволИмениФайла = КодСимвола(Сред(ИмяФайлаDeflate, й + 1, 1));
		БуферОкончания.Установить(ТекущееСмещение + ДлинаФиксированнойЧастиCDFH + й, СимволИмениФайла);
	КонецЦикла;
	
	ТекущееСмещение = ТекущееСмещение + ДлинаФиксированнойЧастиCDFH + ДлинаИмениСжатогоФайла;
	
	ТекущееСмещение = ТекущееСмещение + ДлинаДополнительныхДанных;
	
	// [End of central directory record (EOCD)]
	РазмерCentralDirectory		= ДлинаФиксированнойЧастиCDFH + ДлинаИмениСжатогоФайла + ДлинаДополнительныхДанных;
	СмещениеCentralDirectory	= ДлинаФиксированнойЧастиLFH  + ДлинаИмениСжатогоФайла + РазмерСжатогоФайла;
	
	Сигнатура3 = 101010256; // Обязательная сигнатура 0x06054B50

	БуферОкончания.ЗаписатьЦелое32(ТекущееСмещение + См0,  Сигнатура3);            // Обязательная сигнатура 0x06054B50
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См4,  0);                     // Номер диска
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См6,  0);  // Номер диска, где находится начало Central Directory
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См8,  1);  // Количество записей в Central Directory в текущем диске
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См10, 1);                        // Всего записей в Central Directory
	БуферОкончания.ЗаписатьЦелое32(ТекущееСмещение + См12, РазмерCentralDirectory);   // Размер Central Directory
	БуферОкончания.ЗаписатьЦелое32(ТекущееСмещение + См16, СмещениеCentralDirectory); // Смещение Central Directory
	БуферОкончания.ЗаписатьЦелое16(ТекущееСмещение + См20, 0);                        // Длина комментария
	
	ПотокЗаписи.Записать(БуферОкончания, 0, БуферОкончания.Размер);
	ПотокЗаписи.Закрыть();

	Возврат ПутьКАрхивуZIP;

КонецФункции // ПреобразоватьАрхивEFDвZIP()

// Функция - вычисляет размер заголовка ZIP-файла в байтах
//
// Параметры:
//  РазмерИмениИсходногоФайла   - Число     - размер имени сжатого файла в байтах
//
// Возвращаемое значение:
//  Число  - размер заголовка файла в байтах
//
Функция ПолучитьРазмерЗаголовкаZIPФайла(РазмерИмениИсходногоФайла)

	Р0 = 0; // 0-е смещение
	Р2 = 2; // смещение 2 байта
	Р4 = 4; // смещение 4 байта

	Возврат Р4 + Р2 + Р2 + Р2 + Р2 + Р2 + Р4 + Р4 + Р4 + Р2 + Р2 + РазмерИмениИсходногоФайла + Р0;
	
КонецФункции // ПолучитьРазмерЗаголовкаZIPФайла()

// Функция - вычисляет размер окончания ZIP-файла в байтах
//
// Параметры:
//  РазмерИмениИсходногоФайла   - Число     - размер имени сжатого файла в байтах
//
// Возвращаемое значение:
//  Число  - размер окончания файла в байтах
//
Функция ПолучитьРазмерОкончанияZIPФайла(РазмерИмениИсходногоФайла)

	Р0 = 0; // 0-е смещение
	Р2 = 2; // смещение 2 байта
	Р4 = 4; // смещение 4 байта

	РазмерCentralDirectoryFileHeader  = Р4 + Р2 + Р2 + Р2 + Р2 + Р2 + Р2 + Р4 + Р4 + Р4 + Р2 + Р2 + Р2 + Р2 + Р2
	                                  + Р4 + Р4 + РазмерИмениИсходногоФайла + Р0 + Р0;
	
	РазмерEndOfCentralDirectoryRecord = Р4 + Р2 + Р2 + Р2 + Р2 + Р4 + Р4 + Р2 + Р0;
	
	Возврат РазмерCentralDirectoryFileHeader +
			РазмерEndOfCentralDirectoryRecord;

КонецФункции // ПолучитьРазмерОкончанияZIPФайла()

// Функция - читает структуру файлов в архиве Deflate
//
// Параметры:
//  ПутьКФайлуDeflate                 - Строка    - путь к файлу Deflate для обработки
//
// Возвращаемое значение:
//  Массив(Структура)   - список файлов в архиве
//      *Имя                - Строка   - имя файла
//      *ПолноеИмя          - Строка   - имя файла с путем
//      *Размер             - Число    - размер файла в байтах
//      *Смещение           - Число    - абсолютное смещение файла
//
Функция ПолучитьСписокФайловВАрхиве(ПутьКФайлуDeflate)

	ФайлыВАрхиве = Новый Массив();
	
	Поток = ПутьКФайлуDeflate;

	НачальноеСмещение = 0;
	
	См4  = 4;
	См8  = 8;
	См16 = 16;

	// первые 4 байта - возможно, заголовок или кол-во пакетов данных
	НачальноеСмещение = НачальноеСмещение + См4;
	
	КолВоЯзыковыхБлоков = ПрочитатьРазмер(Поток, НачальноеСмещение);
	НачальноеСмещение = НачальноеСмещение + См4;
	
	Для й = 1 По КолВоЯзыковыхБлоков Цикл
		ДлинаЯзыковогоБлока = ПрочитатьРазмер(Поток, НачальноеСмещение);
		НачальноеСмещение = НачальноеСмещение + ДлинаЯзыковогоБлока;
	КонецЦикла;
	
	КолВоФайлов = ПрочитатьРазмер(Поток, НачальноеСмещение);
	НачальноеСмещение = НачальноеСмещение + См4;
	
	СмещениеЗаголовка = НачальноеСмещение;
	Для й = 1 По КолВоФайлов Цикл
		ДлинаБлокаИмениФайла	= ПрочитатьРазмер(Поток, СмещениеЗаголовка);
		СмещениеЗаголовка = СмещениеЗаголовка + ДлинаБлокаИмениФайла;
	КонецЦикла;

	СмещениеИмениФайла = НачальноеСмещение;

	Для й = 1 По КолВоФайлов Цикл
		ДлинаБлокаИмениФайла = ПрочитатьРазмер(Поток, СмещениеИмениФайла);
		ДлинаИмениФайла      = ПрочитатьРазмер(Поток, СмещениеИмениФайла + См4);
		ПолноеИмяФайла       = ПрочитатьСтрокуИзПотока(Поток, СмещениеИмениФайла + См8, ДлинаБлокаИмениФайла - См8 - См16);

		Если СтрНайти(ПолноеИмяФайла, "/") = 0 Тогда
			Разделитель = "\";
		Иначе
			Разделитель = "/";
		КонецЕсли;

		ЧастиПути = СтрРазделить(ПолноеИмяФайла, Разделитель);
		ИмяФайла = ЧастиПути[ЧастиПути.ВГраница()];
		
		Если НЕ ПараметрыПриложения.ЭтоWindows() Тогда
			ПолноеИмяФайла = СтрЗаменить(ПолноеИмяФайла, "\", "/");
		КонецЕсли;

		Если ДлинаИмениФайла <> СтрДлина(ПолноеИмяФайла) Тогда
			Сообщить("Ошибка чтения имени файла №" + й);
			Продолжить;
		КонецЕсли;
		
		СмещениеФайла = ПрочитатьРазмер(Поток, СмещениеИмениФайла + ДлинаБлокаИмениФайла - См8);
		РазмерФайла   = ПрочитатьРазмер(Поток, СмещениеИмениФайла + ДлинаБлокаИмениФайла - См4);
		
		ОписаниеФайла = Новый Структура("Имя, ПолноеИмя, Размер, Смещение");
		ОписаниеФайла.Имя       = ИмяФайла;
		ОписаниеФайла.ПолноеИмя = ПолноеИмяФайла;
		ОписаниеФайла.Размер    = РазмерФайла;
		ОписаниеФайла.Смещение  = СмещениеЗаголовка + СмещениеФайла;
		ФайлыВАрхиве.Добавить(ОписаниеФайла);

		СмещениеИмениФайла = СмещениеИмениФайла + ДлинаБлокаИмениФайла;
	КонецЦикла;
	
	Возврат ФайлыВАрхиве;

КонецФункции // ПолучитьСписокФайловВАрхиве()

// Процедура - извлекает указанные файлы из архива Deflate
// и сохраняет их в указанный каталог
//
// Параметры:
//  ПутьКФайлуDeflate                 - Строка         - путь к файлу Deflate для обработки
//  КаталогРаспаковки                 - Строка         - путь к каталогу для сохранения извлеченных файлов
//  КаталогВАрхивеДляРаспаковкиEFD    - Строка         - регулярное выражение, отбора каталогов
//                                                       в архиве EFD для распаковки
//  ВыбранныеФайлы                    - Строка         - имя файла или список файлов для распаковки
//                                      Массив(Строка)   если не указан, то распаковываются все файлы
//  РаспаковкаКаталогов               - Строка         - вариант распаковки каталогов
//
Процедура ЗаписатьВыбранныеФайлы(ПутьКФайлуDeflate,
                                 Знач КаталогРаспаковки,
                                 Знач КаталогВАрхивеДляРаспаковкиEFD,
                                 Знач ВыбранныеФайлы = "",
                                 Знач РаспаковкаКаталогов = "")

	ФайлыВАрхиве = ПолучитьСписокФайловВАрхиве(ПутьКФайлуDeflate);

	МассивФайлов = Новый Массив();

	Если ТипЗнч(ВыбранныеФайлы) = Тип("Строка") Тогда
		Если ЗначениеЗаполнено(ВыбранныеФайлы) Тогда
			МассивФайлов.Добавить(ВыбранныеФайлы);
		КонецЕсли;
	ИначеЕсли ТипЗнч(ВыбранныеФайлы) = Тип("Массив") Тогда
		МассивФайлов = ВыбранныеФайлы;
	Иначе
		ВызватьИсключение СтрШаблон("Некорректно указан список извлекаемых файлов ""%1""!", ВыбранныеФайлы);
	КонецЕсли;

	СистемнаяИнформация = Новый СистемнаяИнформация;
	ЭтоWindows = ПараметрыПриложения.ЭтоWindows();
	
	Если ЭтоWindows Тогда
		Для й = 0 По МассивФайлов.ВГраница() Цикл
			МассивФайлов[й] = ВРег(МассивФайлов[й]);
		КонецЦикла;
		КаталогВАрхивеДляРаспаковкиEFD = ВРег(КаталогВАрхивеДляРаспаковкиEFD);
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(РаспаковкаКаталогов) Тогда
		РаспаковкаКаталогов = ВариантРаспаковкиКаталогаПоУмолчанию(ФайлыВАрхиве);
	КонецЕсли;

	ФайлыКРаспаковке = Новый Массив();

	Для Каждого ТекСтрока Из ФайлыВАрхиве Цикл

		ВремИмя = ?(ЭтоWindows, ВРег(ТекСтрока.Имя), ТекСтрока.Имя);
		ВремПолноеИмя = ?(ЭтоWindows, ВРег(ТекСтрока.ПолноеИмя), ТекСтрока.ПолноеИмя);

		Если ЗначениеЗаполнено(КаталогВАрхивеДляРаспаковкиEFD) Тогда
			Если Служебный.НайтиСовпаденияВТексте(ВремПолноеИмя, КаталогВАрхивеДляРаспаковкиEFD).Количество() = 0 Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		Если МассивФайлов.Количество() > 0 Тогда
			Если МассивФайлов.Найти(ВремИмя) = Неопределено
			   И МассивФайлов.Найти(ВремПолноеИмя) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		ФайлыКРаспаковке.Добавить(ТекСтрока);

	КонецЦикла;

	ОбщийПуть = "";
	Если РаспаковкаКаталогов = Перечисления.ВариантыРаспаковкиКаталогов.БезОбщихКаталогов Тогда
		ОбщийПуть = Служебный.ОбщийПутьФайлов(ФайлыКРаспаковке);
	КонецЕсли;

	Поток = ПутьКФайлуDeflate;
	
	Для Каждого ТекСтрока Из ФайлыКРаспаковке Цикл

		КаталогРаспаковкиФайла = КаталогРаспаковкиФайла(ТекСтрока, КаталогРаспаковки, ОбщийПуть, РаспаковкаКаталогов);

		ЗаписатьФайл(Поток, ТекСтрока, КаталогРаспаковкиФайла);

	КонецЦикла;

КонецПроцедуры // ЗаписатьВыбранныеФайлы()

// Процедура - сохраняет указанный файл из потока по указанному пути
// 
// Параметры:
//  Поток               - Поток        - поток с данными файла
//  ОписаниеФайла       - Структура    - описание файла в архиве
//      *Имя                - Строка       - имя файла
//      *ПолноеИмя          - Строка       - имя файла с путем
//      *Размер             - Число        - размер файла в байтах
//      *Смещение           - Число        - смещение файла в потоке
//  КаталогРаспаковки   - Строка       - путь к каталогу для сохранения файла
//
Процедура ЗаписатьФайл(Поток, Знач ОписаниеФайла, Знач КаталогРаспаковки)

	ПутьКФайлу = ОбъединитьПути(КаталогРаспаковки, ОписаниеФайла.Имя);
	ОбеспечитьКаталог(ПутьКФайлу, Истина);

	Чтение = Новый ЧтениеДанных(Поток);
	Чтение.Пропустить(ОписаниеФайла.Смещение);
	ЗаписьДанных = Новый ЗаписьДанных(ПутьКФайлу);

	ПорцияДанных = 10 * 1024 * 1024; // 10 Мб
	Остаток = ОписаниеФайла.Размер;

	Пока Остаток > 0 Цикл
		БуферДанные = Чтение.ПрочитатьВБуферДвоичныхДанных(Мин(Остаток, ПорцияДанных));
		ЗаписьДанных.ЗаписатьБуферДвоичныхДанных(БуферДанные);
		Остаток = Остаток - ПорцияДанных;
	КонецЦикла;

	Чтение.Закрыть();
	ЗаписьДанных.Закрыть();
	
	Лог.Информация(СтрШаблон("Записан файл %1", ПутьКФайлу));

КонецПроцедуры // ЗаписатьФайл()

#КонецОбласти // СлужебныеПроцедурыИФункцииРаботыАрхивами

#Область СлужебныеПроцедурыИФункции

// Преобразует переданное в виде строки число из системы счисления с указанным основанием
// в десятичную систему счисления
// 
// Параметры:
//  СтрЧисло        - Строка    - число в виде строки для преобразования
//  Основание       - Число     - основание системы счисления
//
// Возвращаемое значение:
//  Число  - десятичное число
//
Функция RadixToDec(СтрЧисло, Основание = 10)

	МинОснование = 2;
	МаксОснование = 36;
	Основание10 = 10;

	Если Основание < МинОснование ИЛИ Основание > МаксОснование Тогда
		ВызватьИсключение "Преобразование между системами счисления возможно для оснований от 2 до 36";
	КонецЕсли;
	
	Если Основание = Основание10 Тогда
		Возврат Число(СтрЧисло);
	КонецЕсли;
	
	Алфавит = "0123456789ABCDEFGHIGKLMNOPQRSTUVWXYZ";
	ИтоговоеЧисло = 0;
	
	Для й = 0 По СтрДлина(СтрЧисло) - 1 Цикл
		Цифра = Сред(СтрЧисло, СтрДлина(СтрЧисло) - й, 1);
		ЗначениеЦифры = СтрНайти(Алфавит, Цифра) - 1;
		
		Если ЗначениеЦифры < Основание Тогда
			ИтоговоеЧисло = ИтоговоеЧисло + ЗначениеЦифры * Pow(Основание, й);	
		Иначе 
			ВызватьИсключение "Число за пределами возможного для данного основания";
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИтоговоеЧисло;

КонецФункции // RadixToDec()

// Преобразует переданное число из десятичной системы счисления
// в систему счисления с указанным основанием
// 
// Параметры:
//  ДесятичноеЧисло   - Строка    - число для преобразования
//  Основание         - Число     - основание системы счисления результата
//  МаксДлина         - Число     - фиксированная длина результата
//
// Возвращаемое значение:
//  Строка  - число в виде строки - результат преобразования
//
Функция DecToRadix(Знач ДесятичноеЧисло, Основание = 10, МаксДлина = 0)

	МинОснование = 2;
	МаксОснование = 36;
	Основание10 = 10;

	Если Основание < МинОснование ИЛИ Основание > МаксОснование Тогда
		ВызватьИсключение "Преобразование между системами счисления возможно для оснований от 2 до 36";
	КонецЕсли;
	
	Если ДесятичноеЧисло <= 0 Тогда
		Возврат "0";
	КонецЕсли;
	
	Если Основание = Основание10 Тогда
		Возврат Формат(ДесятичноеЧисло, "ЧГ=0");
	КонецЕсли;
	
	Алфавит = "0123456789ABCDEFGHIGKLMNOPQRSTUVWXYZ";
	Буфер = "";
	Результат = "";
	
	Пока ДесятичноеЧисло > 0 Цикл
		Остаток = ДесятичноеЧисло % Основание;
		Буфер = Буфер + Сред(Алфавит, Остаток + 1, 1);
		ДесятичноеЧисло = Цел(ДесятичноеЧисло / Основание);
	КонецЦикла;
	
	Для й = 1 По МаксДлина - СтрДлина(Буфер) Цикл
		Результат = Результат + "0";
	КонецЦикла;
	
	Для й = -СтрДлина(Буфер) По -1 Цикл
		Результат = Результат + Сред(Буфер, -й, 1);
	КонецЦикла;
	
	Возврат Результат;

КонецФункции // DecToRadix()

// Функция - выделяет время из указанной даты и преобразует в формат для файловой системы FAT
// 
// Параметры:
//  ДатаВремя   - Дата    - дата для преобразования
//
// Возвращаемое значение:
//  Число  - время в формате для файловой системы FAT
//
Функция ВремяFAT(ДатаВремя)
	
	// https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#Format_Time
	
	Час = Час(ДатаВремя);
	Мин = Минута(ДатаВремя);
	Сек = Цел(Секунда(ДатаВремя) / 2);
	
	ВремяБинарное = DecToRadix(Час, 2, 5) + DecToRadix(Мин, 2, 6) + DecToRadix(Сек, 2, 5);
	
	Возврат RadixToDec(ВремяБинарное, 2);

КонецФункции // ВремяFAT()

// Функция - выделяет дату из указанной даты и преобразует в формат для файловой системы FAT
// 
// Параметры:
//  ДатаВремя   - Дата    - дата для преобразования
//
// Возвращаемое значение:
//  Число  - дата в формате для файловой системы FAT
//
Функция ДатаFAT(ДатаВремя)
	
	// https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#Format_Date
	
	НачГод = 1980;

	Год = Год(ДатаВремя) - НачГод;
	Мес = Месяц(ДатаВремя);
	Ден = День(ДатаВремя);
	
	ДатаБинарная = DecToRadix(Год, 2, 7) + DecToRadix(Мес, 2, 4) + DecToRadix(Ден, 2, 5);
	
	Возврат RadixToDec(ДатаБинарная, 2);

КонецФункции // ДатаFAT()

// Функция - читает 4 байта из потока по указанному смещения
// используется для чтения размера файла из заголовка архива
//
// Параметры:
//	Поток       - Поток   - поток для чтения
//	Смещение    - Число   - смещение от начала потока
//
// Возвращаемое значение:
//	Число     - размер файла
//
Функция ПрочитатьРазмер(Поток, Смещение)

	Чтение = Новый ЧтениеДанных(Поток);
	Чтение.Пропустить(Смещение);
	БуферРазмер = Чтение.ПрочитатьВБуферДвоичныхДанных(4);
	Чтение.Закрыть();

	Возврат БуферРазмер.ПрочитатьЦелое32(0);

КонецФункции // ПрочитатьРазмер()

// Функция - читает строку указанного размера из потока по указанному смещению
//
// Параметры:
//	Поток       - Поток   - поток для чтения
//	Смещение    - Число   - смещение от начала потока
//	Размер      - Число   - размер считываемых данных в байтах
//
// Возвращаемое значение:
//	Строка     - прочитанная строка
//
Функция ПрочитатьСтрокуИзПотока(Поток, Смещение, Размер)

	Чтение = Новый ЧтениеДанных(Поток);
	Чтение.Пропустить(Смещение);
	БуферСтроки = Чтение.ПрочитатьВБуферДвоичныхДанных(Размер);
	Чтение.Закрыть();

	Возврат ПолучитьСтрокуИзБуфера(БуферСтроки);

КонецФункции // ПрочитатьСтрокуИзПотока()

// Функция - читает буфер и преобразует результат чтения в строку
//
// Параметры:
//	БинарныйБуфер    - БуферДвоичныхДанных   - буфер для чтения
//
// Возвращаемое значение:
//	Строка     - прочитанная строка
//
Функция ПолучитьСтрокуИзБуфера(БинарныйБуфер)
	
	Результат = "";
	ДлинаБинарника = БинарныйБуфер.Размер;
	Позиция = 0;
	Сдвиг = 2;

	Пока Позиция < ДлинаБинарника Цикл
		Код = БинарныйБуфер.ПрочитатьЦелое16(Позиция);
		Позиция = Позиция + Сдвиг;
		Результат = Результат + Символ(Код);
	КонецЦикла;
	
	Возврат Результат;

КонецФункции // ПолучитьТекстИзБуфера()

// Процедура - извлекает первый файл из ZIP-архива 
//
// Параметры:
//  ПутьКАрхивуZIP      - Строка     - путь к ZIP-архиву
//  КаталогРаспаковки   - Строка     - путь к каталогу для сохранения результата распаковки,
//                                     если не указан то совпадает с расположением ZIP-архива
//
Процедура ИзвлечьФайлИзАрхиваZIP(ПутьКАрхивуZIP, КаталогРаспаковки = "")

	ВремФайлАрхива = Новый Файл(ПутьКАрхивуZIP);

	Если НЕ ЗначениеЗаполнено(КаталогРаспаковки) Тогда
		КаталогРаспаковки = ВремФайлАрхива.Путь;
	КонецЕсли;

	Файл = Новый ЧтениеZipФайла(ПутьКАрхивуZIP);
	
	Попытка
		Файл.Извлечь(Файл.Элементы[0], КаталогРаспаковки);
		//файл извлечется, хотя здесь возникнет исключение из-за некорректных размера файла и контрольной суммы
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстСообщения = СтрШаблон("Ошибка извлечения файла ""%1"" из архива ""%2"": %3%4",
		                           Файл.Элементы[0].Имя,
		                           ПутьКАрхивуZIP,
		                           Символы.ПС,
		                           ТекстОшибки);
		ПараметрыПриложения.Лог().Отладка(ТекстСообщения);
	КонецПопытки;

	Файл.Закрыть();

КонецПроцедуры // ИзвлечьФайлИзАрхиваZIP()

// Функция - ищет и возвращает путь к архиватору 7-zip с использованием команды where/whereis
//
// Возвращаемое значение:
//  Строка   - путь к исполняемому файлу архиватора 7-zip
//
Функция НайтиАрхиваторКомандойПоиска()

	ЭтоWindows = ПараметрыПриложения.ЭтоWindows();
	НайденныйПуть = Неопределено;

	Команда = Новый Команда();

	Если ЭтоWindows Тогда
		Команда.УстановитьКоманду("where");
	Иначе
		Команда.УстановитьКоманду("whereis");
	КонецЕсли;
	Команда.ДобавитьПараметр("7z");

	КодВозврата = Команда.Исполнить();
	ВыводКоманды = Команда.ПолучитьВывод();

	Если КодВозврата = 0 Тогда
		НайденныйПуть = ВыводКоманды;
		Если НЕ ЭтоWindows Тогда
			НайденныйПуть = СтрЗаменить(НайденныйПуть, "7z:", ""); 
			ЧастиСтроки = СтрРазделить(СокрЛП(НайденныйПуть), " ");
			НайденныйПуть = ЧастиСтроки[0];

			Если ПустаяСтрока(НайденныйПуть) Тогда
				НайденныйПуть = Неопределено;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Возврат НайденныйПуть;

КонецФункции // НайтиАрхиваторКомандойПоиска()

// Функция - ищет и возвращает путь к архиватору 7-zip в стандартных каталогах установки программ
//
// Возвращаемое значение:
//  Строка   - путь к исполняемому файлу архиватора 7-zip
//
Функция НайтиАрхиваторВКаталогахПрограмм()

	КаталогиПрограмм = Новый Массив();

	Если ПараметрыПриложения.ЭтоWindows() Тогда
		КаталогиПрограмм.Добавить(ПолучитьПеременнуюСреды("ProgramFiles"));
		КаталогиПрограмм.Добавить(ПолучитьПеременнуюСреды("ProgramFiles(x86)"));
		ИмяИсполняемогоФайла = "7z.exe";
	Иначе
		КаталогиПрограмм.Добавить("/usr/bin");
		КаталогиПрограмм.Добавить("/usr/local/bin");
		ИмяИсполняемогоФайла = "7z";
	КонецЕсли;

	НайденныйПуть = Неопределено;

	Для Каждого ТекКаталог Из КаталогиПрограмм Цикл
		Массив7ZIP = НайтиФайлы(ТекКаталог, ИмяИсполняемогоФайла, True);
		Если Массив7ZIP.Количество() > 0 Тогда
			НайденныйПуть = Массив7ZIP[0].ПолноеИмя;
			Прервать;
		КонецЕсли;
	КонецЦикла;

	Возврат НайденныйПуть;

КонецФункции // НайтиАрхиваторВКаталогахПрограмм()

// Функция - ищет и возвращает путь к архиватору 7-zip
//
// Возвращаемое значение:
//  Строка   - путь к исполняемому файлу архиватора 7-zip
//
Функция НайтиАрхиватор()

	НайденныйПуть = НайтиАрхиваторКомандойПоиска();

	Если НЕ ЗначениеЗаполнено(НайденныйПуть) Тогда
		НайденныйПуть = НайтиАрхиваторВКаталогахПрограмм();
	КонецЕсли;

	Возврат НайденныйПуть;

КонецФункции // НайтиАрхиватор()

// Функция - возвращает вариант распаковки каталогов по умолчанию
//
// Параметры:
//  ФайлыВАрхиве     - Массив(Структура)   - список файлов в архиве
//      *Имя             - Строка              - имя файла
//      *ПолноеИмя       - Строка              - имя файла с путем
//      *Размер          - Число               - размер файла в байтах
//      *Смещение        - Число               - абсолютное смещение файла
//
// Возвращаемое значение:
//  Строка               - вариант распаковки файлов:
//                         если есть файлы с одинаковым именем, то "БезОбщихКаталогов",
//                         в противном случае "БезКаталогов"
//
Функция ВариантРаспаковкиКаталогаПоУмолчанию(ФайлыВАрхиве)

	Для й = 0 По ФайлыВАрхиве.ВГраница() - 1 Цикл
		Для к = й + 1 По ФайлыВАрхиве.ВГраница() Цикл
			Если ФайлыВАрхиве[й].Имя = ФайлыВАрхиве[к].Имя Тогда
				Возврат Перечисления.ВариантыРаспаковкиКаталогов.БезОбщихКаталогов;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

	Возврат Перечисления.ВариантыРаспаковкиКаталогов.БезКаталогов;

КонецФункции // ВариантРаспаковкиКаталогаПоУмолчанию()

// Функция - возвращает полный путь к каталогу для распаковки файла
//
// Параметры:
//  ОписаниеФайла        - Структура       - описание файла для распаковки
//      *Имя             - Строка              - имя файла
//      *ПолноеИмя       - Строка              - имя файла с путем
//      *Размер          - Число               - размер файла в байтах
//      *Смещение        - Число               - абсолютное смещение файла
//  КаталогРаспаковки    - Строка         - путь к каталогу для сохранения извлеченных файлов
//  ОбщийПуть            - Строка         - общая для всех файлов часть пути
//  РаспаковкаКаталогов  - Строка         - вариант распаковки каталогов
//
// Возвращаемое значение:
//  Строка               - полный путь к каталогу для распаковки файла
//
Функция КаталогРаспаковкиФайла(ОписаниеФайла, КаталогРаспаковки, ОбщийПуть, РаспаковкаКаталогов)

	Если РаспаковкаКаталогов = Перечисления.ВариантыРаспаковкиКаталогов.ВсеКаталоги Тогда
		КаталогРаспаковкиФайла = ОбъединитьПути(КаталогРаспаковки, ОписаниеФайла.ПолноеИмя);
	ИначеЕсли РаспаковкаКаталогов = Перечисления.ВариантыРаспаковкиКаталогов.БезОбщихКаталогов Тогда
		Путь = Лев(ОписаниеФайла.ПолноеИмя, СтрДлина(ОписаниеФайла.ПолноеИмя) - СтрДлина(ОписаниеФайла.Имя));
		Путь = Сред(Путь, СтрДлина(ОбщийПуть) + 1);
		КаталогРаспаковкиФайла = ОбъединитьПути(КаталогРаспаковки, Путь);
	Иначе
		КаталогРаспаковкиФайла = КаталогРаспаковки;
	КонецЕсли;

	Возврат КаталогРаспаковкиФайла;

КонецФункции // КаталогРаспаковкиФайла()

// Функция - создает необходимые каталоги для указанного пути
//
// Параметры:
//	Путь       - Строка     - проверяемый путь
//	ЭтоФайл    - Булево     - Истина - в параметре "Путь" передан путь к файлу
//                            Ложь - передан каталог
//
// Возвращаемое значение:
//	Булево     - указанный путь доступен
//
Функция ОбеспечитьКаталог(Знач Путь, Знач ЭтоФайл = Ложь) Экспорт
	
	ВремФайл = Новый Файл(Путь);
	
	Если ЭтоФайл Тогда
		Путь = Сред(ВремФайл.Путь, 1, СтрДлина(ВремФайл.Путь) - 1);
		ВремФайл = Новый Файл(Путь);
	КонецЕсли;
	
	Если НЕ ВремФайл.Существует() Тогда
		Если ОбеспечитьКаталог(Сред(ВремФайл.Путь, 1, СтрДлина(ВремФайл.Путь) - 1)) Тогда
			СоздатьКаталог(Путь);
		Иначе
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ВремФайл.ЭтоКаталог() Тогда
		ВызватьИсключение СтрШаблон("По указанному пути ""%1"" не удалось создать каталог", Путь);
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // ОбеспечитьКаталог()

#КонецОбласти // СлужебныеПроцедурыИФункции

Лог = ПараметрыПриложения.Лог();